# Section 1

## An Ethereum Network
* Networks are used to transfer money and store data
* Many different networks (testnet, mainnet)
* Networks are formed by nodes
* Each node is a machine running an Ethereum client
* Anyone can run a node
* Each node can contain a full copy of the blockchain
* The blockchain is a database that stores a record of every transaction that has ever taken place on the network

## Interfacing with the Network
* For developers
    * web3.js
        * Send money, data or deploy contracts
* For consumers
    * Metamask
        * Browser extension that allows users to interact with the network

## Metamask account
* External accounts: 'human' owned
* Account address: unique identifier that can be shared, shows others who "you are"
    * Same address will be used on all networks (Rpsten, Kovan, Rinkeby, etc)
    * Is a hashed version of the public key
* Public key: allows you to be a receiver in a transaction
* Private key: reqyured to "unlock" funds received. Used to authorize the sending of funds from your account to other accounts
* All 3 are hexadecimal encoded numbers

## Faucet
* Used to fund account with test ETH (by network)
    * https://faucets.chain.link/rinkeby
* Ether received on Rinkeby testnet will not be available on the Kovan testnet

## What's a transaction?
* Transfers funds from one account to another
* Transaction is created when an exchange of funds between two accounts occurs
* Properties
    * nonce: how many times (a "counter") the sender has sent a transaction
        * Ex: if the account has never transacted before, the nonce will be 0. For the first transaction, the nonce will be 1; the second transaction, the nonce will be 2, etc
    * to: address of account this money is going to
    * value: amount of ether to send to the target address
    * gasPrice: amount of ether the sender is willing to pay per unit gas to get this transaction processed
    * startGas/gasLimit: units of gas that this transaction can consume
    * v/r/s: cryptographic pieces of data that can be used to generate the senders account address. Generated from the SENDER'S private key via a one way process
        * v/r/s can be generated by a private key
        * a private key cannot be generated by v/r/s
    
## Getting a transaction confirmed
* 'Transaction' object gets sent to a node on the network
    * This one node will communicate to the rest of the network on our behalf
* The node has an entire copy of the blockchain
* Many other transactions (from other accounts) will send transactions to the same node
* The node then assembles all transactions into a 'block' and runs 'validation logic' on the block
    * 'validation logic' is intentionally oversimplified here. In principle, it refers to mining

## Smart contracts and accounts
* An account controlled by code
* Contract account properties
    * balance: amount of ether this accounts owns
    * storage: data storage for this contract
        * any type of data relevant to the app we are trying to make
    * code: raw machine code for this contract
        * compiled down instructions for the contract
* Account is assigned to a specific network and cannot be access across networks
    * This differs from external metamask account where an address can be used on all networks
* A user creates the smart contracts source code and then deploys it on a network
    * This deployment creates an instance of the contract (referred to as the "contracts account") on the network
    * We can take one contracts source code and deploy it multiple times to a network (or multiple networks)
        * This is extremely similar to 'class' and 'instance' in the programming world of python, java, et al
        * The source code acts as a 'class'
        * The multiple deployments act as 'instances'

## Solidity
* Language used specifically to author smart contracts
    * Written in .sol files
    * Strongly typed language
    * Similar to Javascript
* Solidity compiler produces two separate files
    * Byte code deployed to the network (and stuffed into our contracts account)
    * Application Binary Interface (ABI)
        * Front-end cannot interact with byte code deployed on the blockchain
        * ABI translates the smart contract for our front-end into something that is legible, allowing us to interact with the smart contract

## Setting up Remix
* Use compiler: 0.4.17+commit.bdeb9e52
* Compiler configuration: auto compile

## Writing the first contract



