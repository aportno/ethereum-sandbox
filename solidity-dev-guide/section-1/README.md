# Section 1

## An Ethereum Network
* Networks are used to transfer money and store data
* Many different networks (testnet, mainnet)
* Networks are formed by nodes
* Each node is a machine running an Ethereum client
* Anyone can run a node
* Each node can contain a full copy of the blockchain
* The blockchain is a database that stores a record of every transaction that has ever taken place on the network

## Interfacing with the Network
* For developers
    * web3.js
        * Send money, data or deploy contracts
* For consumers
    * Metamask
        * Browser extension that allows users to interact with the network

## Metamask account
* External accounts: 'human' owned
* Account address: unique identifier that can be shared, shows others who "you are"
    * Same address will be used on all networks (Rpsten, Kovan, Rinkeby, etc)
    * Is a hashed version of the public key
* Public key: allows you to be a receiver in a transaction
* Private key: reqyured to "unlock" funds received. Used to authorize the sending of funds from your account to other accounts
* All 3 are hexadecimal encoded numbers

## Faucet
* Used to fund account with test ETH (by network)
    * https://faucets.chain.link/rinkeby
* Ether received on Rinkeby testnet will not be available on the Kovan testnet

## What's a transaction?
* Transfers funds from one account to another
* Transaction is created when an exchange of funds between two accounts occurs
* Properties
    * nonce: how many times (a "counter") the sender has sent a transaction
        * Ex: if the account has never transacted before, the nonce will be 0. For the first transaction, the nonce will be 1; the second transaction, the nonce will be 2, etc
    * to: address of account this money is going to
    * value: amount of ether to send to the target address
    * gasPrice: amount of ether the sender is willing to pay per unit gas to get this transaction processed
    * startGas/gasLimit: units of gas that this transaction can consume
    * v/r/s: cryptographic pieces of data that can be used to generate the senders account address. Generated from the SENDER'S private key via a one way process
        * v/r/s can be generated by a private key
        * a private key cannot be generated by v/r/s
    
## Getting a transaction confirmed
* 'Transaction' object gets sent to a node on the network
    * This one node will communicate to the rest of the network on our behalf
* The node has an entire copy of the blockchain
* Many other transactions (from other accounts) will send transactions to the same node
* The node then assembles all transactions into a 'block' and runs 'validation logic' on the block
    * 'validation logic' is intentionally oversimplified here. In principle, it refers to mining

## Smart contracts and accounts
* An account controlled by code
* Contract account properties
    * balance: amount of ether this accounts owns
    * storage: data storage for this contract
        * any type of data relevant to the app we are trying to make
    * code: raw machine code for this contract
        * compiled down instructions for the contract
* Account is assigned to a specific network and cannot be access across networks
    * This differs from external metamask account where an address can be used on all networks
* A user creates the smart contracts source code and then deploys it on a network
    * This deployment creates an instance of the contract (referred to as the "contracts account") on the network
    * We can take one contracts source code and deploy it multiple times to a network (or multiple networks)
        * This is extremely similar to 'class' and 'instance' in the programming world of python, java, et al
        * The source code acts as a 'class'
        * The multiple deployments act as 'instances'

## Solidity
* Language used specifically to author smart contracts
    * Written in .sol files
    * Strongly typed language
    * Similar to Javascript
* Solidity compiler produces two separate files
    * Byte code deployed to the network (and stuffed into our contracts account)
    * Application Binary Interface (ABI)
        * Front-end cannot interact with byte code deployed on the blockchain
        * ABI translates the smart contract for our front-end into something that is legible, allowing us to interact with the smart contract

## Setting up Remix
* Use compiler: 0.4.17+commit.bdeb9e52
* Compiler configuration: auto compile

## Writing contracts in Remix
* State (storage) variables are values permanently stored in contract storage on the blockchain
* Local variables have values that are present till function is executing
* Constructor functions are automatically called one time when the contract is first created
    * These name of these functions should match the contract name
* Function types:
    * public: anyone with account can call this function
        * cannot return data if function modifies contract
        * example:
            * if a contract is deployed and has a function available, then any user with an address can interact with the contract and read or modify its contents (depending on what the function does)
            * if account 0x17f deploys the contract that has a function that changes a state variable
                * account 0x5c6 can call the state variable or change the state variable of the contract
                * account 0x036 can do the same, etc
    * private: only the contracts code can call this function
        * cannot return data if function modifies contract
    * view: this function returns data and does NOT modify the contract's data
        * interchangeable with "constant"
        * essentially is a "read only"
    * pure: function will not modify or even read the contract's data
        * similar to view but is more strict
    * payable: when someone call this function they might send ether along

## Deploying contract in Remix
* Compile script
* Navigate to "deploy & run transactions"
* Set environment to JavaScript VM (London)
* Choose account to act as the sender
    * Remix has a "small" test environment that sets up a number of accounts with pre-funded ETH. Selecting any of these accounts is acceptable
* Gas limit can remain the default value for now
* Value of wei can remain zero for now
* Select the contract we'd like to test deploy
* Hit deploy
* Deployed contracts will populate in the bottom left

## Behind the Scenes of Deployment
* Compared with "money sending transactions" where the "to" field is populated with an address, a "contract transaction" will have an empty "to" field
* If a sender creates a contract transaction (so by extension to "to" field will be blank) then by construction the sender is creating a new contract

## More on Running Functions Than You Want to Know
* You need to submit a transaction anytime you want to change something on the blockchain
* We have to submit a transaction and wait for it to be approved before we can say the data has been changed
* Running contract functions
    * "Calling" a function
        * cannot modify the contracts data
        * can return data
        * runs instantly
        * free to do
    * Sending a transaction to a function
        * can modify a contract's data
        * takes time to execute
            * testnet will show instanteous response, mainnet will take time to get the transaction confirmed
        * returns the transaction hash
        * costs money

## Wei vs Ether
* 1 ether = 10**18 wei
    * minimum wei = 1 or 10**-18 ether
* 1 ether = 10**15 kwei
* 1 ether = 10**12 mwei
* 1 ether = 10**9  gwei
* 1 ether = 10**6 szabo
* 1 ether = 10**3 finney

## Gas and transactions
* Cost to run your code on the blockchain
* Gas is required anytime a user wants to send a TRANSACTION is sent to the network
* gasPrice = amount of wei the sender is willing to pay PER UNIT of gas to get this transaction processed
* startGas/gasLimit = units of gas that this transaction can consume (total gas we're willing to spend on the transaction)
* Example:
    * Assume we write a func called "doMath" which does 4 operations (adds two numbers, subtracts two numbers, multiplys two numbers, checks if one number is equal to 0)
    * We set the gasPrice at 300, meaning we are willing to spend 300 wei for every unit of gas
    * We set the gasLimit at 10, meaning we are willing to spend 10 units of gas
    * In total we are willing to spend 300 wei/gas * 10 units of gas = 3000 wei on the transaction
    * Assume to cost of calling doMath is:
        * add = 3 gas
        * subtract = 3 gas
        * multiply = 5 gas
        * equality = 3 gas
        * total gas required for the function = 3 + 3 + 5 + 3 = 14 gas
    * We've specfied the gas limit at 10, so our function would halt before executing the multiply operation given we'd breach our gas limit if multiply was run (3 + 3 + 5 = 11 gas > 10 gas limit)
    * Adjusting the gas limit > 14 gas would allow us to call doMath and complete all of its operations
    * The total cost to call the function would be:
        * 300 wei/gas * 14 gas = 4,200 wei > 3,000 wei we were willing to pay to execute the transaction


## Mnemonic Phrases
* A user can have many different accounts (i.e., MetaMask accounts)
    * One address to spend money
    * One address for savings
    * One address for business
* Each account will have:
    * An address
    * A public key
    * A private key
* So in total 3 addresses will have 3 "properties" or "identifiers" = 9 identifiers to manage in total
* This is a lot of information to handle, so Ethereum invented the concept of 12 word Mnemonic
    * The 12 word mnemonic allows us to generate a series of different accounts with a public key, private key, and address
* The 12 words are fed into a BIP39 mnemonic algorithm which produces the same list of accounts every time
    * So all public and private keys for each account is derived from the mnemonic phrase
    * IT IS MUCH MORE IMPORTANT TO KEEP THE MNEMONIC PHRASE SAFE THAN INDIVIDUAL ADDRESSES/PK!
* To get a new mnemonic phrase, you need to uninstall/reinstall metamask
* You can rederive all accounts/addresses/pk but entering your mnemonic phrase at https://iancoleman.io/bip39/



